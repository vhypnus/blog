redis是一款高性能的缓存，主要有以下几个原因

- 纯内存，所有数据存储在内存，不涉及到IO读取
- NIO，多路复用
- 单线程，避免多线程上下文切换成本

redis提升了丰富的数据结构，主要包括

- string，底层一个map数据结构

> string如何实现，append如何解决扩容问题

- list

> 链表，内存不要求联系，不用提心扩容

- sorted set

> 排序原理

- map

> hash扩容如何解决 

- 布隆过滤器



# 原理

## 扩容

- string扩容
- hash扩容

## 失效

- 随机
- 访问失效
- LRU



#  实践

实践主要关注的场景

- 缓存不存在

缓存不存在的原因有两种

- 没有
- 失效

缓存不存在容易引发问题的场景主要有

- 热点key，某个key的并发访问大

> 累计增加
>
> 累计减少

- 很多key同时失效

> 解决方案：
>
> 
>
> 



## 缓存击穿

## 缓存穿透

## 雪崩

## 宕机



## 缓存一致性

- 定期失效-->更新















# 设计

之所以有如此高的性能，有如下几个设计要点

- 单线程

> **优势**
>
> 1. 避免多线程上下文切换带来的性能开销
> 2. 避免因为多线程而引发的资源竞争及锁冲突

- NIO

> 这是单线程模型的基础，如果没有NIO技术就不会有这样的解决方案

- 基于内存

> 所有数据只存储在内存

- 数据结构

> - 哈希数据结构，string
> - 链表
> - zset
> - GeoHash
> - stream
> - bitmap



# 实现要点

- 因为是单线程，过期及扩容的解决方案
- zset排序功能如果实现
- 如何解决高可用
- 淘汰策略LRU
- 事务如何实现
- 分布式锁如何实现
- redis 5 stream数据结构
- redis module 模块化
- 客户端与服务端的心跳机制如何实现



# 实践

- 缓存与数据库一致性如何保证

>一般不建议使用强一致性解决方案

- 如何避免雪崩
- 如何避免击穿
- 如何避免穿透
- 如何优化大字段缓存

> 1. 避免存储一些没有用的大字段，比如描述性的文件大字段
> 2. 使用HashMap数据结构，只取需要的字段
> 3. 优化序列化方式，因为序列化方式变了，会影响通过redis-cli客户端查看功能



# 参考资料

[redis官方文档](https://redis.io/topics/modules-intro)